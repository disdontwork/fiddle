<!DOCTYPE html>
<html>
<head>
    <title>Realtime Webcam Displacement</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
        #controls {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            color: white;
            font-family: Arial;
        }
        #video {
            display: none;
        }
        #processedCanvas {
            position: fixed;
            top: 10px;
            right: 10px;
            width: 160px;
            height: 120px;
            border: 2px solid white;
        }
    </style>
</head>
<body>
    <div id="controls">
        <button id="startWebcam">Start Webcam</button><br><br>
        <input type="file" id="imageInput" accept="image/*"><br><br>
        Displacement: <input type="range" id="displacementScale" min="0" max="2" step="0.1" value="1"><br>
        Segments: <input type="range" id="segments" min="1" max="256" step="1" value="128">
    </div>
    
    <video id="video" autoplay></video>
    <canvas id="processedCanvas"></canvas>

    <script type="module">
        import * as THREE from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.js';
        
        let plane, material, videoTexture;
        let isWebcamActive = false;
        const processedCanvas = document.getElementById('processedCanvas');
        const processedCtx = processedCanvas.getContext('2d');
        const video = document.getElementById('video');
        
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Default texture
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 256;
        canvas.height = 256;
        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, 256, 256);
        const defaultTexture = new THREE.CanvasTexture(canvas);

        function createPlane(segments) {
            const geometry = new THREE.PlaneGeometry(5, 5, segments, segments);
            if (!material) {
                material = new THREE.MeshStandardMaterial({
                    color: 0x808080,
                    displacementMap: defaultTexture,
                    displacementScale: 1.0,
                    side: THREE.DoubleSide,
                    metalness: 0.2,
                    roughness: 0.8
                });
            }
            return new THREE.Mesh(geometry, material);
        }

        // Initial plane
        plane = createPlane(128);
        scene.add(plane);

        // Lights
        scene.add(new THREE.AmbientLight(0xffffff, 0.5));
        const pointLight = new THREE.PointLight(0xffffff, 1);
        pointLight.position.set(5, 5, 5);
        scene.add(pointLight);

        camera.position.z = 5;

        // Webcam setup
        document.getElementById('startWebcam').addEventListener('click', async () => {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                video.srcObject = stream;
                video.play();
                
                // Set processed canvas size
                processedCanvas.width = 256;
                processedCanvas.height = 256;
                
                // Create video texture
                videoTexture = new THREE.CanvasTexture(processedCanvas);
                material.displacementMap = videoTexture;
                isWebcamActive = true;
            } catch (err) {
                console.error('Error accessing webcam:', err);
            }
        });

        // Process video frame to grayscale
        function processVideoFrame() {
            if (!isWebcamActive || !video.videoWidth) return;
            
            processedCtx.drawImage(video, 0, 0, processedCanvas.width, processedCanvas.height);
            const imageData = processedCtx.getImageData(0, 0, processedCanvas.width, processedCanvas.height);
            const data = imageData.data;
            
            // Convert to grayscale
            for (let i = 0; i < data.length; i += 4) {
                const gray = (data[i] + data[i + 1] + data[i + 2]) / 3;
                data[i] = data[i + 1] = data[i + 2] = gray;
            }
            
            processedCtx.putImageData(imageData, 0, 0);
            if (videoTexture) {
                videoTexture.needsUpdate = true;
                material.displacementMap = videoTexture;
                material.needsUpdate = true;
            }
        }

        // Handle image upload
        document.getElementById('imageInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                isWebcamActive = false;
                const reader = new FileReader();
                reader.onload = function(e) {
                    const img = new Image();
                    img.onload = function() {
                        const texture = new THREE.Texture(img);
                        texture.needsUpdate = true;
                        material.displacementMap = texture;
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }
        });

        // Handle displacement scale
        document.getElementById('displacementScale').addEventListener('input', function(e) {
            material.displacementScale = parseFloat(e.target.value);
        });

        // Handle segments
        document.getElementById('segments').addEventListener('input', function(e) {
            const segments = parseInt(e.target.value);
            scene.remove(plane);
            plane = createPlane(segments);
            scene.add(plane);
        });

        // Animation
        function animate() {
            requestAnimationFrame(animate);
            if (isWebcamActive) processVideoFrame();
            plane.rotation.x += 0.005;
            plane.rotation.y += 0.005;
            renderer.render(scene, camera);
        }

        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
